<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[浏览器缓存]]></title>
      <url>https://wutongshu1993.github.io/2017/04/01/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/</url>
      <content type="html"><![CDATA[<h1 id="浏览器缓存分类"><a href="#浏览器缓存分类" class="headerlink" title="浏览器缓存分类"></a>浏览器缓存分类</h1><h2 id="什么是浏览器缓存"><a href="#什么是浏览器缓存" class="headerlink" title="什么是浏览器缓存"></a>什么是浏览器缓存</h2><p>浏览器缓存(Brower Caching)是浏览器在本地磁盘对用户最近请求过的文档进行存储，当访问者再次访问同一页面时，浏览器就可以直接从本地磁盘加载文档。</p>
<p>浏览器缓存的优点有：</p>
<ol>
<li>减少了冗余的数据传输，节省了网费</li>
<li>减少了服务器的负担，大大提升了网站的性能</li>
<li>加快了客户端加载网页的速度</li>
</ol>
<h2 id="强制缓存和协商缓存"><a href="#强制缓存和协商缓存" class="headerlink" title="强制缓存和协商缓存"></a>强制缓存和协商缓存</h2><p>浏览器缓存主要有两类：缓存协商和彻底缓存，也有称之为协商缓存和强缓存。</p>
<p>浏览器在第一次请求发生后，再次请求时：</p>
<ol>
<li>浏览器会先获取该资源缓存的header信息，根据其中的expires和cahe-control判断是否命中强缓存，若命中则直接从缓存中获取资源，包括缓存的header信息，本次请求不会与服务器进行通信；<strong>注意！！强制缓存是在客户端进行判断的，不会传到服务器端。包括expires 和 maxage=num这两种形式</strong></li>
<li>如果没有命中强缓存，浏览器会发送请求到服务器，该请求会携带第一次请求返回的有关缓存的header字段信息（Last-Modified/IF-Modified-Since、Etag/IF-None-Match）,由服务器根据请求中的相关header信息来对比结果是否命中协商缓存，若命中，则服务器返回新的响应header信息更新缓存中的对应header信息，但是并不返回资源内容，它会告知浏览器可以直接从缓存获取；否则返回最新的资源内容</li>
</ol>
<h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p>强缓存是利用http的返回头中的Expires或者Cache-Control两个字段来控制的，用来表示资源的缓存时间。</p>
<h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h4><p>该字段是http1.0时的规范，它的值为一个绝对时间的GMT格式的时间字符串，比如Expires:Mon,18 Oct 2066 23:59:59 GMT。这个时间代表着这个资源的失效时间，在此时间之前，即命中缓存。这种方式有一个明显的缺点，由于失效时间是一个绝对时间，所以当服务器与客户端时间偏差较大时，就会导致缓存混乱。</p>
<h4 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h4><p>Cache-Control是http1.1时出现的header信息，主要是利用该字段的max-age值来进行判断，它是一个相对时间，例如Cache-Control:max-age=3600，代表着资源的有效期是3600秒（<strong>注意是秒！！</strong>）。cache-control除了该字段外，还有下面几个比较常用的设置值：</p>
<ul>
<li>no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。</li>
<li>no-store：直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。</li>
<li>public：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。</li>
<li>private：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。</li>
</ul>
<h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>协商缓存就是由服务器来确定缓存资源是否可用，所以客户端与服务器端要通过某种标识来进行通信，从而让服务器判断请求资源是否可以缓存访问，这主要涉及到下面两组header字段，这两组搭档都是成对出现的，即第一次请求的响应头带上某个字段（Last-Modified或者Etag），则后续请求则会带上对应的请求字段（If-Modified-Since或者If-None-Match），若响应头没有Last-Modified或者Etag字段，则请求头也不会有对应的字段。</p>
<h4 id="Last-Modify-If-Modify-Since"><a href="#Last-Modify-If-Modify-Since" class="headerlink" title="Last-Modify/If-Modify-Since"></a>Last-Modify/If-Modify-Since</h4><p>浏览器第一次请求一个资源的时候，服务器返回的header中会加上Last-Modify，Last-modify是一个时间标识该资源的最后修改时间，例如Last-Modify: Thu,31 Dec 2037 23:59:59 GMT。</p>
<p>当浏览器再次请求该资源时，request的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-Modify。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存。</p>
<p>如果命中缓存，则返回304，并且不会返回资源内容，并且不会返回Last-Modify。</p>
<h4 id="ETag-If-None-Match"><a href="#ETag-If-None-Match" class="headerlink" title="ETag/If-None-Match"></a>ETag/If-None-Match</h4><p>与Last-Modify/If-Modify-Since不同的是，Etag/If-None-Match返回的是一个校验码。ETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化。服务器根据浏览器上送的If-None-Match值来判断是否命中缓存。</p>
<p>与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化。</p>
<h4 id="为什么要有Etag"><a href="#为什么要有Etag" class="headerlink" title="为什么要有Etag"></a>为什么要有Etag</h4><p>你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag呢？HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：</p>
<ul>
<li>一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；</li>
<li>某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；</li>
<li>某些服务器不能精确的得到文件的最后修改时间。</li>
</ul>
<p>Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。</p>
<h2 id="和缓存有关的头部以及不同头部之间的优先级关系"><a href="#和缓存有关的头部以及不同头部之间的优先级关系" class="headerlink" title="和缓存有关的头部以及不同头部之间的优先级关系"></a>和缓存有关的头部以及不同头部之间的优先级关系</h2><ol>
<li>通用首部字段<br><img src="\images\通用头部.jpg" alt="通用头部"></li>
<li>请求头部<br><img src="\images\请求头部.jpg" alt="请求头部"></li>
<li><p>响应头部<br><img src="\images\响应首部.jpg" alt="响应首部"><br><img src="\images\实体首部.jpg" alt="实体首部"></p>
</li>
<li><p>缓存判断的过程</p>
</li>
</ol>
<p><img src="\images\粗略过程.jpg" alt="粗略过程"><br><img src="\images\详细过程.jpg" alt="详细过程"></p>
<h2 id="无法被缓存的请求"><a href="#无法被缓存的请求" class="headerlink" title="无法被缓存的请求"></a>无法被缓存的请求</h2><p>当然并不是所有请求都能被缓存。</p>
<p>无法被浏览器缓存的请求：</p>
<ol>
<li>HTTP信息头中包含Cache-Control:no-cache，pragma:no-cache（HTTP1.0），或Cache-Control:max-age=0等告诉浏览器不用缓存的请求</li>
<li>需要根据Cookie，认证信息等决定输入内容的动态请求是不能被缓存的</li>
<li>经过HTTPS安全加密的请求（有人也经过测试发现，ie其实在头部加入Cache-Control：max-age信息，firefox在头部加入Cache-Control:Public之后，能够对HTTPS的资源进行缓存，参考《HTTPS的七个误解》）</li>
<li>POST请求无法被缓存</li>
<li>HTTP响应头中不包含Last-Modified/Etag，也不包含Cache-Control/Expires的请求无法被缓存</li>
</ol>
<h2 id="浏览器清除缓存的方法"><a href="#浏览器清除缓存的方法" class="headerlink" title="浏览器清除缓存的方法"></a>浏览器清除缓存的方法</h2><ol>
<li><p>meta元数据，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;META HTTP-EQUIV=&quot;pragma&quot; CONTENT=&quot;no-cache&quot;&gt; </div><div class="line">&lt;META HTTP-EQUIV=&quot;Cache-Control&quot; CONTENT=&quot;no-cache, must-revalidate&quot;&gt; </div><div class="line">&lt;META HTTP-EQUIV=&quot;expires&quot; CONTENT=&quot;0&quot;&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>用ajax请求最新文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">beforeSend :function(xmlHttp)&#123; </div><div class="line">        xmlHttp.setRequestHeader(&quot;If-Modified-Since&quot;,&quot;0&quot;); </div><div class="line">        xmlHttp.setRequestHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;);</div><div class="line">     &#125;,</div><div class="line">或者直接用cache：false</div></pre></td></tr></table></figure>
</li>
<li><p>在请求的URL后加上随机数或者时间戳</p>
</li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> 缓存 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[session和cookie的区别和联系]]></title>
      <url>https://wutongshu1993.github.io/2017/04/01/session%E5%92%8Ccookie%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB/</url>
      <content type="html"><![CDATA[<h1 id="session-和cookie的区别和联系"><a href="#session-和cookie的区别和联系" class="headerlink" title="session 和cookie的区别和联系"></a>session 和cookie的区别和联系</h1><p>由于http协议是无连接，无状态的，因此服务器是不会保存客户信息的，需要借助cookie和session来完成。</p>
<h2 id="session和cookie的区别"><a href="#session和cookie的区别" class="headerlink" title="session和cookie的区别"></a>session和cookie的区别</h2><ol>
<li>存储位置不一样，cookie存在浏览器，session存在服务器端。</li>
<li>存取类型不同，cookie只能存Unicode字符或者二进制数据，需要先进行编码。而session可以存取任何类型的数据。</li>
<li>有效时间不同，对于非持久性session来说，session只在会话期间有效。为防止内存溢出，服务器会把长时间内没有活跃的Session从内存删除。这个时间就是Session的超时时间。如果超过了超时时间没访问过服务器，Session就自动失效了。而cookie有会话cookie和永久cookie之分。</li>
<li>跨域支持不同，cookie对该域及其子域都是有效的，session只对当前域有效。</li>
<li>容量大小也不同，cookie的容量最多4KB，session应该是没有限制的。</li>
</ol>
<h2 id="cookie的产生"><a href="#cookie的产生" class="headerlink" title="cookie的产生"></a>cookie的产生</h2><p>首先需要明白的cookie需要在每次请求指定domain域的时候都会携带，所以只有4kB的容量。</p>
<p>cookie是一段很小的文本信息，客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。通过在response中添加响应头setCookie实现，如：Set-Cookie: JsessionID=D356DFFF33AA134DAB; Max-Age=3600; Version=1。 客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。</p>
<p>当cookie已经产生了，下一次再发送请求的时候，就会根据cookie中的sessionID来查出服务器端对应的session，同时一个session中可以有多个attribute。</p>
<h2 id="session的用法"><a href="#session的用法" class="headerlink" title="session的用法"></a>session的用法</h2><p>在java中Session对应的类为javax.servlet.http.HttpSession类。getAttribute(Stringkey)和setAttribute(String key，Objectvalue)。常用的方法还有session.getId</p>
<p>session的存储有效的问题，不是常说session是在会话期间有效吗？那我们关掉浏览器后再次打开淘宝session怎么还存在呢？</p>
<p>情况是这样的。一般情况下，session都是存储在内存里，当服务器进程被停止或者重启的时候，内存里的session也会被清空，如果设置了session的持久化特性，服务器就会把session保存到硬盘上，当服务器进程重新启动或这些信息将能够被再次使用，Weblogic Server支持的持久性方式包括文件、数据库、客户端cookie保存和复制。 </p>
<h2 id="session和cookie的联系"><a href="#session和cookie的联系" class="headerlink" title="session和cookie的联系"></a>session和cookie的联系</h2><p>当程序需要为某个客户端的请求创建一个session的时候，服务器首先检查这个客户端的请求里是否已包含了一个session标识 - 称为session id，如果已包含一个session id则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（如果检索不到，可能会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存</p>
<p>其中cookie中的JsessionID对应的value就是在服务器端的session.getId()的返回值。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/linguoguo/p/5106618.html" target="_blank" rel="external">http://www.cnblogs.com/linguoguo/p/5106618.html</a></p>
<p><a href="http://justsee.iteye.com/blog/1570652" target="_blank" rel="external">http://justsee.iteye.com/blog/1570652</a> 很好的一篇文章</p>
]]></content>
      
        
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[js基本类型和引用类型小结]]></title>
      <url>https://wutongshu1993.github.io/2017/03/19/js%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%B0%8F%E7%BB%93/</url>
      <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>基本类型</strong>指的是简单的数据段，String Number Undefined Null Boolean这五种，他们的值保存在栈中。<strong>引用类型</strong>指的是可能由多个值构成的对象，值保存在堆中。</p>
<p>为什么会有堆和栈之分呢？因为每个函数执行时都会建立自己的内存栈，调用结束就释放内存。堆内存中的对象不会随着调用的结束而销毁，只有当一个对象没有任何引用变量引用时，系统的垃圾回收机制才会回收它。</p>
<h2 id="变量的赋值"><a href="#变量的赋值" class="headerlink" title="变量的赋值"></a>变量的赋值</h2><p>对于基本类型来说，如果从一个变量A向另一个变量B赋基本类型的值，会将A的值复制一份，然后把复制后的值给B。事实上就是A,B在栈中指向不同的位置，完全不相关。</p>
<p>对于引用类型来说，操作对象实际上操作的是对象的引用，（当为对象添加属性的时候，操作的是实际的对象）。当将Obj赋值给newObj时，也会将存储在变量对象obj中的值复制一份到为新变量newObj分配的空间中，但是这个值的副本实际上是一个指针，指向存储在堆中的一个对象。因此改变newObj会影响到obj。</p>
<p><img src="/images/引用赋值.jpg" alt="image"></p>
<h3 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h3><p>浅拷贝：两个对象指向的是堆中的同一个对象，一方改变，另一个也会改变。</p>
<h4 id="数组的深拷贝的实现："><a href="#数组的深拷贝的实现：" class="headerlink" title="数组的深拷贝的实现："></a>数组的深拷贝的实现：</h4><ol>
<li>var newArray = array.slice(0);</li>
<li>var newArray = array.contact();</li>
</ol>
<h4 id="对象的深拷贝"><a href="#对象的深拷贝" class="headerlink" title="对象的深拷贝"></a>对象的深拷贝</h4><ol>
<li>var newObj = Json.parse( Json.stringfy(obj) );</li>
<li>var newObj = Object.create(obj);//把obj当做是newObj的原型进行创建<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function clone(obj) &#123;</div><div class="line">    var newObj = &#123;&#125;;</div><div class="line">    for(var i in obj)&#123;</div><div class="line">        newObj[obj[i]] = typeof obj[i] === &apos;object&apos; ? clone(obj[i]) : obj[i];</div><div class="line">    &#125;</div><div class="line">    return newObj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h2><h3 id="基本类型传参"><a href="#基本类型传参" class="headerlink" title="基本类型传参"></a>基本类型传参</h3><p>基本类型的传参和基本类型的赋值相同，都是复制一个临时变量。</p>
<p><img src="/images/基本类型的参数传递.jpg" alt="image"></p>
<p>因此，在函数addTen中改变的值只是一个临时变量的值，并不会影响到num本身。</p>
<h3 id="引用类型传参"><a href="#引用类型传参" class="headerlink" title="引用类型传参"></a>引用类型传参</h3><p>引用类型的传参传递的也是值，而不是引用。</p>
<p><img src="/images/引用类型传参1.jpg" alt="image"></p>
<p>这里，虽然是按值传递的，其实还是指向的是堆内存中唯一一个变量。</p>
<p>下面这个例子可以证明引用类型的参数传递是按值传递的，而不是按地址传递的。</p>
<p><img src="/images/引用类型按值传参证明.jpg" alt="image"></p>
<p>这里，在全局变量中有一个person，如果是按引用传递的，那么在setName函数内部对obj的改变应该会反映到person上面，但是并不会。事实上内部新建的obj之后，这个变量引用就是一个局部变量，函数执行完了就销毁了，并不会影响到外部的person。</p>
]]></content>
      
        
        <tags>
            
            <tag> 引用类型 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[BFC及其应用]]></title>
      <url>https://wutongshu1993.github.io/2017/03/16/BFC%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<h1 id="BFC是什么"><a href="#BFC是什么" class="headerlink" title="BFC是什么"></a>BFC是什么</h1><p>Box 是 CSS 布局的对象和基本单位， 直观点来说，就是一个页面是由很多个 Box 组成的。元素的类型和 display 属性，决定了这个 Box 的类型。 不同类型的 Box， 会参与不同的 Formatting Context（一个决定如何渲染文档的容器），因此Box内的元素会以不同的方式渲染。让我们看看有哪些盒子：</p>
<ul>
<li>block-level box:display 属性为 block, list-item, table 的元素，会生成 block-level box。并且参与 block fomatting context；</li>
<li>inline-level box:display 属性为 inline, inline-block, inline-table 的元素，会生成 inline-level box。并且参与 inline formatting context；<blockquote>
<p>BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。</p>
<h2 id="BFC的布局规则"><a href="#BFC的布局规则" class="headerlink" title="BFC的布局规则"></a>BFC的布局规则</h2></blockquote>
</li>
</ul>
<ol>
<li>内部的Box会在垂直方向，一个接一个地放置。</li>
<li>Box垂直方向的距离由margin决定。<strong>属于同一个BFC的两个相邻Box的margin会发生重叠</strong>（这就是大名鼎鼎的margin折叠）</li>
<li>每个元素的margin box的左边， 与包含块border</li>
<li>box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</li>
<li><strong>BFC的区域不会与float box重叠。</strong>（这个可以用来自适应布局）</li>
<li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li>
<li><strong>计算BFC的高度时，浮动元素也参与计算</strong>（这个可以用来清除浮动）</li>
</ol>
<h2 id="哪些元素会生成BFC"><a href="#哪些元素会生成BFC" class="headerlink" title="哪些元素会生成BFC"></a>哪些元素会生成BFC</h2><ul>
<li>根元素</li>
<li>float属性不为none</li>
<li>position为absolute或fixed</li>
<li>display为inline-block, table-cell, table-caption, flex, inline-flex</li>
<li>overflow不为visible</li>
</ul>
<h2 id="BFC的作用"><a href="#BFC的作用" class="headerlink" title="BFC的作用"></a>BFC的作用</h2><h3 id="自适应两栏布局"><a href="#自适应两栏布局" class="headerlink" title="自适应两栏布局"></a>自适应两栏布局</h3><p>一般来说加了浮动之后块级元素之间会出现重叠的现象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">body&#123;</div><div class="line">           width: 900px;</div><div class="line">           margin: 0 auto;</div><div class="line">       &#125;</div><div class="line">       .aside &#123;</div><div class="line">           width: 200px;</div><div class="line">           height: 150px;</div><div class="line">           float: left;</div><div class="line">           background: #f66;</div><div class="line">       &#125;</div><div class="line">       .content &#123;</div><div class="line">           height: 200px;</div><div class="line">           background: #fcc;</div><div class="line">       &#125;</div></pre></td></tr></table></figure></p>
<p><img src="/images/bfc1_1.jpg" alt="image">  </p>
<p>运用第5条规则：BFC的区域不会与float box重叠。所以我们只要触发右边的.content的BFC属性，便可是实现自适应，而不重叠的布局。</p>
<p><img src="/images/bfc1_2.jpg" alt="image"></p>
<h3 id="清除内部浮动："><a href="#清除内部浮动：" class="headerlink" title="清除内部浮动："></a>清除内部浮动：</h3><p>我们常说，清除内部浮动有如下几种办法：</p>
<ol>
<li>给父元素加上overflow:hidden或者是overflow:auto</li>
<li>在父元素::after加上clear:both</li>
<li>给父元素加上浮动</li>
</ol>
<p>其实清除浮动的原理就是利用触发父元素的BFC属性了。</p>
<h3 id="清除margin折叠"><a href="#清除margin折叠" class="headerlink" title="清除margin折叠"></a>清除margin折叠</h3><p>相邻的两个div，他们会发生margin折叠，清除margin折叠有以下方法：其核心在于使两个相邻的块级元素处于不同的BFC块中。</p>
<ol>
<li>给其中一个块级元素的外部再套上一个div元素，并触发这个元素的BFC属性</li>
</ol>
<p>事实上，不仅相邻的box元素会发生折叠，父子元素之间也会存在这样的现象。解决的方法是给父级元素加上内边距或者边框。</p>
]]></content>
      
        
        <tags>
            
            <tag> bfc margin折叠 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[懒加载]]></title>
      <url>https://wutongshu1993.github.io/2017/03/13/%E6%87%92%E5%8A%A0%E8%BD%BD/</url>
      <content type="html"><![CDATA[<ol>
<li><p>在html中给img指定两个图片资源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;img src=&quot;default.jpg&quot; dataSrc=&quot;img.jpg&quot;&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>lazyload函数</p>
</li>
</ol>
<p>核心在于当满足了img.offset &lt; scrolllTop + window.innerHeight的时候，替换img的 src<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var imgs = document.getElementsByTagName(&apos;img&apos;);</div><div class="line">    function lazyload()&#123;</div><div class="line">        var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;</div><div class="line">        var viewportSize = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;</div><div class="line">        var len = imgs.length;</div><div class="line">        var i , n = 0;</div><div class="line">        for(i = n; i &lt; len; i++)&#123;</div><div class="line">            var offsetTop = imgs[i].offsetTop;</div><div class="line">            if(offsetTop &lt; scrollTop + viewportSize)&#123;//显示真正的图片</div><div class="line">                imgs[i].src = imgs[i].getAttribute(&apos;dataSrc&apos;);</div><div class="line">            &#125;</div><div class="line">            n = i + 1;//避免每次for循环都是从0开始</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>优化：将lazyload函数绑定在window的onscroll事件中<br>window.onscroll = throttle(lazyload, 500, 1000);</li>
<li>优化<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     *</div><div class="line">     * @param fun 要执行的函数</div><div class="line">     * @param delay 延时的时间</div><div class="line">     * @param time 在time内执行一次</div><div class="line">     */</div><div class="line">    function throttle(fun, delay, time) &#123;</div><div class="line">        var timeout, startTime = new Date();</div><div class="line">        return function()&#123;</div><div class="line">            var context = this,</div><div class="line">                    args = arguments,</div><div class="line">                    curTime = new Date();</div><div class="line">            clearTimeout(timeout);</div><div class="line">            //如果到达了触发时间</div><div class="line">            if(curTime - startTime &gt;= time)&#123;</div><div class="line">                fun.apply(context, args);</div><div class="line">                startTime = curTime;</div><div class="line">            &#125;</div><div class="line">            else &#123;//没到达触发时间，重新设置定时器</div><div class="line">                timeout = setTimeout(fun, delay);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    lazyload();//至少执行一次</div><div class="line">    window.onscroll = throttle(lazyload, 500, 1000);</div></pre></td></tr></table></figure></li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> 优化 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo搭建博客]]></title>
      <url>https://wutongshu1993.github.io/2017/03/13/hello-hexo/</url>
      <content type="html"><![CDATA[<p>欢迎来到我的个人博客</p>
]]></content>
      
        
        <tags>
            
            <tag> nodejs， hexo， nextT </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>https://wutongshu1993.github.io/2017/03/13/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
      
        
    </entry>
    
  
  
</search>
