<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[js事件机制]]></title>
      <url>https://wutongshu1993.github.io/2018/05/03/js%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6-md/</url>
      <content type="html"><![CDATA[<blockquote>
<p>感觉最近过的浑浑噩噩的，应该静下心来学习一些知识了，不管以后是做前端还是后端，静下心来学习总归是重要的。用胡适先生的话来鼓励自己：管什么真理无穷，进一寸有进一寸的欢喜。</p>
</blockquote>
<h1 id="调用栈与任务队列"><a href="#调用栈与任务队列" class="headerlink" title="调用栈与任务队列"></a>调用栈与任务队列</h1><p>在js是一门单线程语言，这里的单线程指的是在JS引擎中负责解释和执行js代码的线程只有一个，叫做main thread。</p>
<p>但是实际上还存在其他的线程。例如：处理AJAX请求的线程、处理DOM事件的线程、定时器线程、读写文件的线程(例如在Node.js中)等等。这些线程可能存在于JS引擎之内，也可能存在于JS引擎之外，在此我们不做区分。不妨叫它们工作线程。</p>
<p>在js的事件机制中很重要的两个概念是调用堆栈和任务队列，调用堆栈可以想象成同步任务，任务队列中保存的是已经满足条件需要被执行的异步任务的回调函数。对一个调用堆栈中的task进行处理的时候，其他都得等着。如果在执行过程中遇到setTimeout等异步操作的时候，<strong>会把setTimeOut交给浏览器的其他模块</strong>(以webkit为例，是webcore模块)进行处理，<strong>当到达setTimeout指定的延时执行的时间之后，task(回调函数)会放入到任务队列之中</strong>。一般不同的异步任务的回调函数会放入不同的任务队列之中。<strong>等到调用栈中所有task执行完毕之后，接着去执行任务队列之中的task(回调函数)。</strong></p>
<p><img src="https://pic2.zhimg.com/80/v2-e902447823cf13e5a547214363233858_hd.jpg" alt="image"></p>
<p>在上图中，调用栈中遇到DOM操作、ajax请求以及setTimeout等WebAPIs的时候就会交给浏览器内核的其他模块进行处理，webkit内核在Javasctipt执行引擎之外，有一个重要的模块是webcore模块。对于图中WebAPIs提到的三种API，webcore分别提供了DOM Binding、network、timer模块来处理底层实现。等到这些模块处理完这些操作的时候将回调函数放入任务队列中，之后等栈中的task执行完之后再去执行任务队列之中的回调函数。</p>
<h2 id="setTimeOut与循环机制"><a href="#setTimeOut与循环机制" class="headerlink" title="setTimeOut与循环机制"></a>setTimeOut与循环机制</h2><ol>
<li>首先将main函数的执行上下文入栈<br><img src="https://pic1.zhimg.com/80/v2-9e5a3e686df7e84068575121c1ec9fcd_hd.jpg" alt="image"></li>
<li>代码接着执行，遇到console.log(‘Hi’),此时log(‘Hi’)入栈，console.log方法只是一个webkit内核支持的普通的方法，所以log(‘Hi’)方法立即被执行。此时输出’Hi’。</li>
</ol>
<p><img src="https://pic1.zhimg.com/80/v2-1a9a6a95c4a7d3dc45facb5b2545640d_hd.jpg" alt="image"></p>
<ol>
<li>当遇到setTimeout的时候，执行引擎将其添加到栈中。</li>
</ol>
<p><img src="https://pic4.zhimg.com/80/v2-4a8c8a73009cc73d5efdb833fdf81b03_hd.jpg" alt="image"> </p>
<ol>
<li><p>调用栈发现setTimeout是之前提到的WebAPIs中的API，因此将其出栈之后将延时执行的函数交给浏览器的timer模块进行处理。<br><img src="https://pic3.zhimg.com/80/v2-37a7df54154dd521ced4dae2e3470c22_hd.jpg" alt="image"></p>
</li>
<li><p>timer模块去处理延时执行的函数，此时执行引擎接着执行将log(‘SJS’)添加到栈中，此时输出’SJS’<br><img src="https://pic2.zhimg.com/80/v2-800d6abf4bcdef9a354c9d60f2882a26_hd.jpg" alt="image"></p>
</li>
<li><p>当timer模块中延时方法规定的时间到了之后就将其放入到任务队列之中，此时调用栈中的task已经全部执行完毕。<br><img src="https://pic4.zhimg.com/80/v2-e804f07a0d9b0436941e3e48550349b9_hd.jpg" alt="image"></p>
</li>
<li><p>调用栈中的task执行完毕之后，执行引擎会接着看执行任务队列中是否有需要执行的回调函数。这里的cb函数被执行引擎添加到调用栈中，接着执行里面的代码，输出’there’。等到执行结束之后再出栈。</p>
</li>
</ol>
<p><img src="https://pic1.zhimg.com/80/v2-c3c2686ecfa45b21ff3bc99b0252b90b_hd.jpg" alt="image"><br><img src="https://pic4.zhimg.com/80/v2-f78ad9009fd2622c139f2da66f61d19b_hd.jpg" alt="image"></p>
<h1 id="事件机制深入理解"><a href="#事件机制深入理解" class="headerlink" title="事件机制深入理解"></a>事件机制深入理解</h1><blockquote>
<p>接下来将介绍SetTimeOut,SetInterval,Promise,nextTick等函数在时间机制中的执行时机。</p>
</blockquote>
<p>先看一段代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">(function test() &#123;</div><div class="line">    setTimeout(function() &#123;console.log(4)&#125;, 0);</div><div class="line">    new Promise(function executor(resolve) &#123;</div><div class="line">        console.log(1);</div><div class="line">        for( var i=0 ; i&lt;10000 ; i++ ) &#123;</div><div class="line">            i == 9999 &amp;&amp; resolve();</div><div class="line">        &#125;</div><div class="line">        console.log(2);</div><div class="line">    &#125;).then(function() &#123;</div><div class="line">        console.log(5);</div><div class="line">    &#125;);</div><div class="line">    console.log(3);</div><div class="line">&#125;)()</div></pre></td></tr></table></figure></p>
<p>输出1，2，3，5，4 你做对了吗？</p>
<p>在这段代码里面，setTimeout和Promise都被称之为任务源，来自不同任务源的回调函数会被放进不同的任务队列里面。setTimeout的回调函数被放进setTimeout的任务队列之中。而对于Promise,它的回调函数并不是传进去的executer函数，而是其异步执行的then方法里面的参数，被放进Promise的任务队列之中。也就是说==Promise的第一个参数并不会被放进Promise的任务队列之中，而会在当前队列就执行，而将then方法里面的参数放进Promise的任务队列中。==</p>
<h2 id="macro-task宏任务与micro-task微任务"><a href="#macro-task宏任务与micro-task微任务" class="headerlink" title="macro-task宏任务与micro-task微任务"></a>macro-task宏任务与micro-task微任务</h2><ol>
<li>macro-task包括：<strong>script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering。</strong></li>
<li>micro-task包括：<strong>process.nextTick, Promises, Object.observe, MutationObserver</strong></li>
</ol>
<p>事件循环的顺序是从script开始第一次循环，随后全局上下文进入函数调用栈，碰到macro-task就将其交给处理它的模块处理完之后将回调函数放进macro-task的队列之中，碰到micro-task也是将其回调函数放进micro-task的队列之中。直到函数调用栈清空只剩全局执行上下文，然后开始执行所有的micro-task。当所有可执行的micro-task执行完毕之后。循环再次执行macro-task中的一个任务队列，执行完之后再执行所有的micro-task，就这样一直循环。</p>
<p>总的来说</p>
<ol>
<li>不同的任务会放进不同的任务队列之中。</li>
<li>先执行macro-task（这里指的是整体代码，非异步代码），等到函数调用栈清空之后再执行所有在队列之中的micro-task。</li>
<li>等到所有macro-task执行完之后再从micro-task中的一个任务队列开始执行，就这样一直循环。</li>
<li>当有多个macro-task(micro-task)队列时，事件循环的顺序是按上文macro-task(micro-task)的分类中书写的顺序执行的。</li>
</ol>
<p>代码段的解释如下：</p>
<ol>
<li>script任务源先执行，全局上下文入栈。<br><img src="https://pic3.zhimg.com/80/v2-51325b7f24ce7f979e9288e82a1230e0_hd.jpg" alt="image"></li>
<li>script任务源的代码在执行时遇到setTimeout,作为一个macro-task，将其回调函数放入自己的队列之中。<br><img src="https://pic4.zhimg.com/80/v2-9bc7b1147a343d8e989d64f408642e35_hd.jpg" alt="image"> </li>
<li>script任务源的代码在执行时遇到Promise实例。Promise构造函数中的第一个参数是在当前任务直接执行不会被放入队列之中，因此此时输出 1 。<br><img src="https://pic2.zhimg.com/80/v2-9b60523cf5eb759edb4181f51c441105_hd.jpg" alt="image"><br>4.在for循环里面遇到resolve函数，函数入栈执行之后出栈，此时Promise的状态变成Fulfilled。代码接着执行遇到console.log(2),输出2。<br><img src="https://pic4.zhimg.com/80/v2-84b2608d1e36e66e847189f4a83eda20_hd.jpg" alt="image"></li>
<li>接着执行，代码遇到then方法，其回调函数作为micro-task入栈，进入Promise的任务队列之中。<br><img src="https://pic2.zhimg.com/80/v2-b074f0faafd94060fb0718ca5feda83b_hd.jpg" alt="image"></li>
<li>代码接着执行，此时遇到console.log(3),输出3。<br><img src="https://pic1.zhimg.com/80/v2-b88fe4ed91a895869c376aa6fa0185c3_hd.jpg" alt="image"></li>
<li>输出3之后第一个宏任务script的代码执行完毕，这时候开始开始执行所有在队列之中的micro-task。then的回调函数入栈执行完毕之后出栈，这时候输出5<br><img src="https://pic1.zhimg.com/80/v2-b88fe4ed91a895869c376aa6fa0185c3_hd.jpg" alt="image"><br><img src="https://pic3.zhimg.com/80/v2-04d930dcfeadcf46f270c91ef0edee7b_hd.jpg" alt="image"></li>
<li>这时候所有的micro-task执行完毕，第一轮循环结束。第二轮循环从setTimeout的任务队列开始，setTimeout的回调函数入栈执行完毕之后出栈，此时输出4。<br><img src="https://pic2.zhimg.com/80/v2-efbc17856004ba09b844d23c35176c10_hd.jpg" alt="image"></li>
</ol>
<p>终极例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">console.log(&apos;golb1&apos;);</div><div class="line">setImmediate(function() &#123;</div><div class="line">    console.log(&apos;immediate1&apos;);</div><div class="line">    process.nextTick(function() &#123;</div><div class="line">        console.log(&apos;immediate1_nextTick&apos;);</div><div class="line">    &#125;)</div><div class="line">    new Promise(function(resolve) &#123;</div><div class="line">        console.log(&apos;immediate1_promise&apos;);</div><div class="line">        resolve();</div><div class="line">    &#125;).then(function() &#123;</div><div class="line">        console.log(&apos;immediate1_then&apos;)</div><div class="line">    &#125;)</div><div class="line">&#125;)</div><div class="line">setTimeout(function() &#123;</div><div class="line">    console.log(&apos;timeout1&apos;);</div><div class="line">    process.nextTick(function() &#123;</div><div class="line">        console.log(&apos;timeout1_nextTick&apos;);</div><div class="line">    &#125;)</div><div class="line">    new Promise(function(resolve) &#123;</div><div class="line">        console.log(&apos;timeout1_promise&apos;);</div><div class="line">        resolve();</div><div class="line">    &#125;).then(function() &#123;</div><div class="line">        console.log(&apos;timeout1_then&apos;)</div><div class="line">    &#125;)</div><div class="line">    setTimeout(function() &#123;</div><div class="line">        console.log(&apos;timeout1_timeout1&apos;);</div><div class="line">        process.nextTick(function() &#123;</div><div class="line">            console.log(&apos;timeout1_timeout1_nextTick&apos;);</div><div class="line">        &#125;)</div><div class="line">        setImmediate(function() &#123;</div><div class="line">            console.log(&apos;timeout1_setImmediate1&apos;);</div><div class="line">        &#125;)</div><div class="line">    &#125;);</div><div class="line">&#125;)</div><div class="line">new Promise(function(resolve) &#123;</div><div class="line">    console.log(&apos;glob1_promise&apos;);</div><div class="line">    resolve();</div><div class="line">&#125;).then(function() &#123;</div><div class="line">    console.log(&apos;glob1_then&apos;)</div><div class="line">&#125;)</div><div class="line">process.nextTick(function() &#123;</div><div class="line">    console.log(&apos;glob1_nextTick&apos;);</div><div class="line">&#125;)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">golb1</div><div class="line">glob1_promise</div><div class="line">glob1_nextTick</div><div class="line">glob1_then</div><div class="line">timeout1</div><div class="line">timeout1_promise</div><div class="line">timeout1_nextTick</div><div class="line">timeout1_then</div><div class="line">immediate1</div><div class="line">immediate1_promise</div><div class="line">immediate1_nextTick</div><div class="line">immediate1_then</div><div class="line">timeout1_timeout1</div><div class="line">timeout1_timeout1_nextTick</div><div class="line">timeout1_setImmediate1</div></pre></td></tr></table></figure></p>
<p>总结：</p>
<ol>
<li>同步代码执行顺序优先级高于异步代码执行顺序优先级；</li>
<li>new Promise(fn)中的fn是同步执行；</li>
<li>process.nextTick()&gt;Promise.then()&gt;setTimeout&gt;setImmediate。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://zhuanlan.zhihu.com/p/26229293" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/26229293</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/26238030" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/26238030</a></li>
<li><a href="https://www.cnblogs.com/yonglin/p/7857804.html" target="_blank" rel="external">https://www.cnblogs.com/yonglin/p/7857804.html</a></li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> js事件机制 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[webpack配置]]></title>
      <url>https://wutongshu1993.github.io/2017/05/12/webpack%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p>一直以来，都不太会配置webpack，总是用vue-cli或者create-react-app来初始化项目，从而实现零配置。最近在看一本书，《React与Redux实践》，关于webpack，babel等的配置挺好的。本文就着作者思路再次梳理一下了。</p>
<h1 id="在浏览器中运行React"><a href="#在浏览器中运行React" class="headerlink" title="在浏览器中运行React"></a>在浏览器中运行React</h1><h2 id="组件复用"><a href="#组件复用" class="headerlink" title="组件复用"></a>组件复用</h2><p>毫无疑问，一般用react写自己的组件，src/App.js，返回一个hello world<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">import React from &apos;react&apos;;</div><div class="line"></div><div class="line">class App extends React.Component&#123;</div><div class="line">    render()&#123;</div><div class="line">        return &lt;h1&gt;hello world&lt;/h1&gt;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">export  default App;</div></pre></td></tr></table></figure></p>
<p>需要的依赖都在这里，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&quot;dependencies&quot;: &#123;</div><div class="line">    &quot;http-server&quot;: &quot;^0.10.0&quot;,</div><div class="line">    &quot;react&quot;: &quot;^15.5.4&quot;,</div><div class="line">    &quot;react-dom&quot;: &quot;^15.5.4&quot;</div><div class="line">  &#125;,</div><div class="line">  &quot;devDependencies&quot;: &#123;</div><div class="line">    &quot;babel-core&quot;: &quot;^6.24.1&quot;,</div><div class="line">    &quot;babel-loader&quot;: &quot;^7.0.0&quot;,</div><div class="line">    &quot;babel-preset-es2015&quot;: &quot;^6.24.1&quot;,</div><div class="line">    &quot;babel-preset-react&quot;: &quot;^6.24.1&quot;,</div><div class="line">    &quot;babel-register&quot;: &quot;^6.24.1&quot;,</div><div class="line">    &quot;webpack&quot;: &quot;^2.5.1&quot;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h2 id="在浏览器中渲染react组件"><a href="#在浏览器中渲染react组件" class="headerlink" title="在浏览器中渲染react组件"></a>在浏览器中渲染react组件</h2><p>src/client.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">import React from &apos;react&apos;;</div><div class="line">import  &#123; render &#125; from &apos;react-dom&apos;;</div><div class="line">import App from &apos;./src/App&apos;;</div><div class="line"></div><div class="line">render((&lt;App/&gt;), document.querySelector(&apos;#root&apos;));</div></pre></td></tr></table></figure></p>
<h2 id="webpack配置"><a href="#webpack配置" class="headerlink" title="webpack配置"></a>webpack配置</h2><p>因为webpack只有打包功能，所以需要引入babel-loader来实现编译功能。使用webpack和babel-loader打包编译的具体步骤：</p>
<ol>
<li><p>安装webpack和babel-loader,babel-core  </p>
<p> npm install –save-dev webpack babel-loader babel-core</p>
</li>
<li>添加webpack.config.js文件制定打包编译的配置信息：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">    entry: &apos;./src/client&apos;,</div><div class="line">    output:&#123;</div><div class="line">        path: __dirname + &apos;/static/dist&apos;,</div><div class="line">        filename: &apos;main.js&apos;</div><div class="line">    &#125;,</div><div class="line">    module: &#123;</div><div class="line">        loaders: [&#123;test: /\.js$/, exclude: /node_module/, loaders: [&apos;babel-loader&apos;]&#125;]</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>entry表示入口文件，output中的path表示输出目录，filename表示输出文件名称。module这部分表示使用babel-loader来编译除了node-modules文件夹下的.js文件.</p>
<ol>
<li><p>安装babel-preset-es2015和 babel-preset-react预设</p>
<p> npm install –save-dev babel-preset-es2015 babel-preset-react</p>
</li>
<li><p>添加.babelrc，激活es2015和react的预设</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;&quot;presets&quot;: [&quot;react&quot;, &quot;es2015&quot;]&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>编译 </p>
<p> npm run build编译， 因为在package.json中写了</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">  &quot;scripts&quot;: &#123;</div><div class="line">  &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</div><div class="line">  &quot;start&quot;: &quot;webpack &amp;&amp; http-server -p 3000&quot;,</div><div class="line">  &quot;build&quot;: &quot;webpack&quot;</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p> 所以才能用npm run build 以及 npm start</p>
</li>
<li><p>在浏览器中运行</p>
<p>将生成的代码路径加入到index.html中即可运行index.html</p>
</li>
</ol>
<p>至此在浏览器中运行react便完全结束了</p>
]]></content>
      
        
        <tags>
            
            <tag> webpack react babel </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用js实现文件上传]]></title>
      <url>https://wutongshu1993.github.io/2017/05/08/%E7%94%A8js%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
      <content type="html"><![CDATA[<p>一次面试的时候，面试官问我，有没有自己写过文件上传，不依赖任何模板，框架？因此今天特地将文件上传那些事进行总结梳理一下。</p>
<p>本文使用的例子使用nodejs作为后台，jade模板作为前台的来实现文件上传的功能。当然你用其他后台语言也是可以的，我相信道理都是一样的。下面将提到几个小例子，分为普通文件上传，异步上传，显示上传进度，图片预览，多文件上传，拖拽上传这几部分。</p>
<p>[TOC]</p>
<h2 id="普通文件上传"><a href="#普通文件上传" class="headerlink" title="普通文件上传"></a>普通文件上传</h2><p>面试的时候问你文件上传怎么实现，一般人都能答出来，使用input标签，并将type设置为file，同时将form表单设置为multipart/form-data.恩没错，就是这样，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">form(method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;)</div><div class="line">        fieldset</div><div class="line">            legend 文件上传</div><div class="line">            span 文件上传：</div><div class="line">            input#file1(</div><div class="line">                type=&apos;file&apos;</div><div class="line">                name=&quot;file1&quot;</div><div class="line">            )</div><div class="line">            button#submit(type=&quot;button&quot;) 文件上传</div></pre></td></tr></table></figure></p>
<p>这样，当我们提交表单的时候，就会上传该文件了。</p>
<p>那后台怎么处理呢？后台采用的是nodejs推荐的multer模块。</p>
<p><a href="https://github.com/expressjs/multer/blob/master/doc/README-zh-cn.md" target="_blank" rel="external">multer的具体用法</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">var multer = require(&apos;multer&apos;);</div><div class="line">var storage = multer.diskStorage(&#123;</div><div class="line">  //给上传文件重命名，获取添加后缀名</div><div class="line">  filename : function (req, file, cb) &#123;</div><div class="line">    var type = file.originalname.slice(file.originalname.lastIndexOf(&apos;.&apos;));//截取后缀</div><div class="line">    var newName = Date.now()+type;</div><div class="line">    console.log(newName);</div><div class="line">    cb(null, newName);</div><div class="line">  &#125;,</div><div class="line">  //设置上传后文件路径</div><div class="line">  destination: function (req, file, cb) &#123;</div><div class="line">    cb(null, &apos;uploads/&apos;)</div><div class="line">  &#125;,</div><div class="line">&#125;)</div><div class="line">//添加配置文件到multer对象</div><div class="line">var upload = multer(&#123;</div><div class="line">  storage : storage</div><div class="line">&#125;);</div><div class="line"></div><div class="line">//使用</div><div class="line">app.post(&apos;/upload&apos;,upload.single(&apos;file1&apos;),  (req, res) =&gt; &#123;</div><div class="line">    console.log(req);</div><div class="line">    res.send(&apos;success&apos;);</div><div class="line">  &#125;)</div></pre></td></tr></table></figure></p>
<p>这里需要在根目录下建一个uploads文件夹。</p>
<h2 id="异步上传"><a href="#异步上传" class="headerlink" title="异步上传"></a>异步上传</h2><p>其实在实际中，我们应该更推荐使用XHR异步上传（我猜的）。这里就不得不说下XMLHttpRequest level2，和level1相比呢，有以下改进：</p>
<ol>
<li>支持接收二进制数据，提供xhr.overrideMimeType()方法，或者通过设置responseType=’blob’</li>
<li>可以上传文件, 可以使用FormData对象管理表单.</li>
<li>提供进度提示, 可通过 xhr.upload.onprogress 事件回调方法获取传输进度.</li>
<li>依然受 同源策略 限制, 这个安全机制不会变. XHR2新提供 Access-Control-Allow-Origin 等headers, 设置为 * 时表示允许任何域名请求,从而实现跨域CORS访问</li>
<li>可以设置timeout 及 ontimeout, 方便设置超时时长和超时后续处理.</li>
</ol>
<p><a href="http://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html" target="_blank" rel="external">详细请参考这里</a></p>
<p>那我们到底应该如何使用呢？诺，像下面这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function upload() &#123;</div><div class="line">            var xhr = new XMLHttpRequest();</div><div class="line">            var formData = new FormData();</div><div class="line">            var fileInput = $(&quot;#file1&quot;)[0];</div><div class="line">            var file = fileInput.files[0];</div><div class="line">            formData.append(&apos;myFile&apos;, file);</div><div class="line">            formData.append(&apos;name&apos;,&apos;ssss&apos;);</div><div class="line">            xhr.open(&apos;POST&apos;, &quot;/upload&quot;);</div><div class="line">            xhr.onload = function () &#123;</div><div class="line">                if (this.status === 200) &#123;</div><div class="line">                    console.log(&quot;success&quot;);</div><div class="line">                &#125;</div><div class="line">                else &#123;</div><div class="line">                    console.log(xhr.status);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            xhr.send(formData);</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<h2 id="提供进度条"><a href="#提供进度条" class="headerlink" title="提供进度条"></a>提供进度条</h2><p>html5提供了一个很好用的progress标签，通过设置total和value就可以显示进度了，并且level 2又恰好提供了onprogress回调函数，是不是感觉so easy呢</p>
<p>首先在jade中增加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sapn 上传进度：</div><div class="line">progress#progress(max=100)</div></pre></td></tr></table></figure></p>
<p>js中，<br>在shr.send调用之前加上下面代码，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//上传进度模块</div><div class="line">            xhr.upload.onprogress = function (event) &#123;</div><div class="line">                if(event.lengthComputable)&#123;</div><div class="line">                    var val = (event.loaded / event.total) * 100;</div><div class="line">                    $(&apos;#progress&apos;).attr(&apos;value&apos;,val)</div><div class="line">                &#125;</div><div class="line">            &#125;</div></pre></td></tr></table></figure></p>
<p>其中事件的lengthComputable属性代表文件总大小是否可知，如果 lengthComputable 属性的值是 false，那么意味着总字节数是未知并且 total 的值为零。</p>
<h2 id="图片预览"><a href="#图片预览" class="headerlink" title="图片预览"></a>图片预览</h2><p>已经实现进度显示了（偷笑），那如何实现图片预览呢？幸运的是，html5新增的File API给我们提供了很大的帮助，这就是大名鼎鼎的FileReader。</p>
<p>h5给input type=file,类型的dom元素增加了files集合，通过文件输入选择一个或多个文件使，files将会包含一组File对象，因此我们可以采用var file = fileInput.files[0];这种模式获取我们选择的文件对象。同时FileReader还提供了</p>
<p>(1). reader.readAsDataURL(file)方法，将文件以数据URI的形式保存在reader对象的result中。</p>
<p>(2). 对象URL，使用对象URL的好处是可以不必把文件内容读取到js中，而直接引用文件内容。因此只要在需要文件内容的地方提供对象的URL即可。</p>
<p>下面就有两种方式实现图片预览</p>
<p>首先需要在jade中添加一个div用于预览图片<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">div#previewImg</div></pre></td></tr></table></figure></p>
<p>js代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//图片预览——使用fileReader中的readAsDataURL方法，在reader.onload中为img.src赋值</div><div class="line">        function previewImage(file) &#123;</div><div class="line">            var previewImg = $(&quot;#previewImg&quot;)[0];</div><div class="line">            var img = $(&quot;&lt;img style=&apos;width: 400px; height: 400px&apos;/&gt;&quot;)[0];</div><div class="line">            var fileInput = $(&apos;#file1&apos;)[0];</div><div class="line">            var file = fileInput.files[0];</div><div class="line">            img.file = file;</div><div class="line">            previewImg.appendChild(img);</div><div class="line"></div><div class="line">            var reader = new FileReader();</div><div class="line">            reader.onload = (function (aImg) &#123;</div><div class="line">                return function (e) &#123;</div><div class="line">                    aImg.src = e.target.result;</div><div class="line">                &#125;</div><div class="line">            &#125;)(img);</div><div class="line">            reader.readAsDataURL(file);</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>第二种方式如下：<br>createObjectURL(file)，返回的是一个字符串，指向一块内存的地址，直接把对象的url放在img标签中，img标签会找到相应的内存地址，直接读取数据并将图像显示在页面中。如果不再需要相应的数据，最好释放它占用的内容。胆只用有代码在引用对象URL，内存就不会释放。要手工释放内训，就可以调用window.URL.revokeObjectURL()方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//兼容性的读取对象URL方法</div><div class="line">       function createObjectURL(blob)&#123;</div><div class="line">           if(window.URL)&#123;</div><div class="line">               return window.URL.createObjectURL(blob);</div><div class="line">           &#125;</div><div class="line">           else if(window.webkitURL)&#123;</div><div class="line">               return window.webkitURL.createObjectURL(blob);</div><div class="line">           &#125;</div><div class="line">           else &#123;</div><div class="line">               return null;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       //兼容性的释放数据占用内存的方法</div><div class="line">       function revokeObjectURL(url) &#123;</div><div class="line">           if(window.URL)&#123;</div><div class="line">               window.URL.revoleObjectURL(url);</div><div class="line">           &#125;</div><div class="line">           else if(window.webkitURL)&#123;</div><div class="line">               window.webkitURL.revokeObjectUrl(url);</div><div class="line">           &#125;</div><div class="line">       &#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//第二种图片预览的方法——直接使用createObjectURL(file)读取对应file的url，并将url赋值给img.src。通过查看img的src可以发现二者其实是不同的</div><div class="line">        function previewImage2(file) &#123;</div><div class="line">            var previewImg = $(&quot;#previewImg&quot;)[0];</div><div class="line">            var img = $(&quot;&lt;img style=&apos;width: 200px; height: 200px&apos;/&gt;&quot;)[0];</div><div class="line">            //var fileInput = $(&apos;#file1&apos;)[0];</div><div class="line">            //var file = fileInput.files[0];</div><div class="line">            img.src = createObjectURL(file);</div><div class="line">            img.onload = function () &#123;</div><div class="line">                revokeObjectURL(this.src);</div><div class="line">            &#125;</div><div class="line">            previewImg.appendChild(img);</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>这样图片预览便完美实现了，如果我们想要多个文件预览呢？</p>
<h2 id="多文件预览"><a href="#多文件预览" class="headerlink" title="多文件预览"></a>多文件预览</h2><p>多文件预览首先需要设置input的 multiple属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">input#file1(</div><div class="line">                type=&apos;file&apos;</div><div class="line">                name=&quot;file1&quot;</div><div class="line">                multiple</div><div class="line">            )</div></pre></td></tr></table></figure></p>
<p>然后通过遍历fileInput.files中的文件，再依次调用previewImage(file)方法即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//多文件预览</div><div class="line">        function multipreview() &#123;</div><div class="line">            var fileInput = $(&apos;#file1&apos;)[0];</div><div class="line">            var files = fileInput.files;</div><div class="line">            var formData = new FormData();</div><div class="line">            for(var i = 0; i &lt; files.length; i++)&#123;</div><div class="line">                var file = files[i];</div><div class="line">                previewImage2(file);</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<h2 id="多文件上传"><a href="#多文件上传" class="headerlink" title="多文件上传"></a>多文件上传</h2><p>多文件上传通过遍历fileInput.files属性，并将file依次加入formData中即可， 在后台处理中调用upload.array()方法即可。</p>
<p>js代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">//多文件上传</div><div class="line">       function multiUpload() &#123;</div><div class="line">           var xhr = new XMLHttpRequest();</div><div class="line">           var fileInput = $(&apos;#file1&apos;)[0];</div><div class="line">           var files = fileInput.files;</div><div class="line">           var formData = new FormData();</div><div class="line">           console.log(123);</div><div class="line">           console.log(files.length);</div><div class="line">           for (var i = 0; i &lt; files.length; i++) &#123;</div><div class="line"></div><div class="line">               var file = files[i];</div><div class="line">              formData.append(&apos;files[]&apos;, file, file.name);</div><div class="line">           &#125;</div><div class="line">           xhr.open(&apos;POST&apos;, &quot;/upload&quot;);</div><div class="line">           xhr.onload = function () &#123;</div><div class="line">               if (this.status === 200) &#123;</div><div class="line">                   console.log(&quot;success&quot;);</div><div class="line">               &#125;</div><div class="line">               else &#123;</div><div class="line">                   console.log(xhr.status);</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">           //上传进度模块</div><div class="line">           xhr.upload.onprogress = function (event) &#123;</div><div class="line">               if (event.lengthComputable) &#123;</div><div class="line">                   var val = (event.loaded / event.total) * 100;</div><div class="line">                   $(&apos;#progress&apos;).attr(&apos;value&apos;, val)</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">           xhr.send(formData);</div><div class="line">       &#125;</div></pre></td></tr></table></figure></p>
<p>后台稍微改变了一点点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/处理多个文件的上传</div><div class="line">  app.post(&apos;/upload&apos;,upload.array(&apos;files[]&apos;),  (req, res) =&gt; &#123;</div><div class="line">    res.send(&apos;success&apos;);</div><div class="line">  &#125;)</div></pre></td></tr></table></figure></p>
<p>注意array中的参数一定要和formdata中的key值对应。</p>
<h2 id="文件拖拽上传"><a href="#文件拖拽上传" class="headerlink" title="文件拖拽上传"></a>文件拖拽上传</h2><p>h5中新增了文件拖拽api，当我们把拖拽元素（本例子中的图片文件）拖拽到目标区域（input type=file）上时，会依次触发以下事件：dragenter,dragover, dragleave或drop。因此，我们需要给input type=”file”绑定对应的处理事件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">//实现文件拖拽的上传</div><div class="line">       function dragUpload()&#123;</div><div class="line">           var dropTarget = $(&apos;#file1&apos;);//拖拽的目标当然是input type=&quot;file&quot;，当然也可以是其他的div之类的。</div><div class="line">           function handleEvent (e) &#123;</div><div class="line">               e.stopPropagation();</div><div class="line">               e.preventDefault();</div><div class="line">               var files = e.originalEvent.dataTransfer.files,</div><div class="line">                       data, xhr, i, length;</div><div class="line">               if(e.type === &apos;drop&apos;)&#123;</div><div class="line">                   length = files.length;</div><div class="line">                   xhr = new XMLHttpRequest();</div><div class="line">                   data = new FormData();</div><div class="line">                   i = 0;</div><div class="line">                   while (i &lt; length) &#123;</div><div class="line">                       data.append(&apos;files[]&apos;, files[i]);</div><div class="line">                       i++;</div><div class="line">                   &#125;</div><div class="line">                   xhr.open(&apos;POST&apos;, &quot;/upload&quot;);</div><div class="line">                   xhr.onload = function () &#123;</div><div class="line">                       if (this.status === 200) &#123;</div><div class="line">                           console.log(&quot;success&quot;);</div><div class="line">                       &#125;</div><div class="line">                       else &#123;</div><div class="line">                           console.log(xhr.status);</div><div class="line">                       &#125;</div><div class="line">                   &#125;;</div><div class="line">                   //上传进度模块</div><div class="line">                   xhr.upload.onprogress = function (event) &#123;</div><div class="line">                       if (event.lengthComputable) &#123;</div><div class="line">                           var val = (event.loaded / event.total) * 100;</div><div class="line">                           $(&apos;#progress&apos;).attr(&apos;value&apos;, val)</div><div class="line">                       &#125;</div><div class="line">                   &#125;;</div><div class="line">                   xhr.send(data);</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">           dropTarget.on(&apos;dragenter&apos;, handleEvent);</div><div class="line">           dropTarget.on(&apos;dragover&apos;, handleEvent);</div><div class="line">           dropTarget.on(&apos;drop&apos;, handleEvent);</div><div class="line">       &#125;</div></pre></td></tr></table></figure></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://segmentfault.com/p/1210000009289556/read" target="_blank" rel="external">https://segmentfault.com/p/1210000009289556/read</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html</a></p>
]]></content>
      
        
        <tags>
            
            <tag> js 文件上传 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[web性能优化浅析]]></title>
      <url>https://wutongshu1993.github.io/2017/04/05/web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%B5%85%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="HTTP头部"><a href="#HTTP头部" class="headerlink" title="HTTP头部"></a>HTTP头部</h1><h2 id="压缩头部"><a href="#压缩头部" class="headerlink" title="压缩头部"></a>压缩头部</h2><p>如果浏览器和服务器都支持的话，可以使用压缩来减小响应的大小。</p>
<p>请求头： Accept-Encoding(浏览器可以支持的web服务器返回内容压缩编码类型): gzip, deflate</p>
<p>响应头：Content-Encoding: gzip</p>
<h2 id="条件get请求"><a href="#条件get请求" class="headerlink" title="条件get请求"></a>条件get请求</h2><p>听起来很高大上的样子，其实就是在发送get请求的时候加上一个If-Modified-Since字段，这个时候是属于协商缓存的，服务器会根据If-Modified-Since中的时间和Last-Modified的时间来决定是否返回304.这个时候服务器不再发送响应体（返回的消息就只有响应头？？）。</p>
<h2 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h2><p>如果响应头中包含expires字段，就是用的强制缓存（cache-control 和expires）了，在客户端进行判断，只要没有过期就会使用缓存版本，而不会进行任何HTTP请求。</p>
<h2 id="Keep-Alive"><a href="#Keep-Alive" class="headerlink" title="Keep-Alive"></a>Keep-Alive</h2><p>connection：可以取值为close或者keep-alive</p>
<ol>
<li>在HTTP 1.0中，客户端的每次请求都要求建立一次单独的连接，在处理完本次请求后，就自动释放连接。因此如果要请求一个HTML文件，其中包含10张图片就要产生11个TCP连接。当然多个TCP连接可以并行，但是默认的情况下大部分浏览器打开5~10个并行的TCP连接。</li>
<li>在HTTP 1.1中则可以在一次连接中处理多个请求，并且多个请求可以重叠进行，不需要等待一个请求结束后再发送下一个请求。和1.0中不同的是，多个请求可以共用一个TCP连接，而不用每次都是请求–响应–释放。<br><img src="\images\http1.0和1.1.jpg" alt="image"></li>
</ol>
<p>再说下HTTP2.0中的多路复用问题，事实上，1.1中的长连接每个请求是依次进行的，但是2.0中不是这样。<br><img src="\images\HTTP2.png" alt="image"></p>
<h1 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h1><h2 id="1-减少HTTP请求数量"><a href="#1-减少HTTP请求数量" class="headerlink" title="1. 减少HTTP请求数量"></a>1. 减少HTTP请求数量</h2><p>事实上，解析一个网页只有10%–20%左右的时间花在请求html文档上，剩余80%~90%的时间花在请求html文档所用到的组件上，包括图片/js/css</p>
<h3 id="图片地图"><a href="#图片地图" class="headerlink" title="图片地图"></a>图片地图</h3><p>将导航栏的多个图标用一张图片代替，根据用户点击的位置跳到指定的链接。分为服务器端图片地图和客户端图片地图</p>
<h3 id="雪碧图"><a href="#雪碧图" class="headerlink" title="雪碧图"></a>雪碧图</h3><p>根据background-position来设置</p>
<h3 id="内联图片"><a href="#内联图片" class="headerlink" title="内联图片"></a>内联图片</h3><p>内联图片不会产生http请求，允许小块数据内联为‘立即数’，数据就在url自身当中。</p>
<p>格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data:[&lt;mediatype&gt;][;base64],&lt;data</div></pre></td></tr></table></figure></p>
<p>缺点：</p>
<ol>
<li>浏览器不会缓存内联图片资源</li>
<li>IE8以下不支持</li>
<li>超过100KB的图片，base64编码会使图片大小增大，导致网页整体下载速度减慢</li>
</ol>
<h3 id="合并脚本和样式表"><a href="#合并脚本和样式表" class="headerlink" title="合并脚本和样式表"></a>合并脚本和样式表</h3><p>具体应该用到什么工具呢？如果最后合成一个资源，那减少了HTTP请求和每个页面下载了不需要的代码，该如何取舍呢？</p>
<h2 id="2-使用内容分发网络-CDN"><a href="#2-使用内容分发网络-CDN" class="headerlink" title="2.使用内容分发网络(CDN)"></a>2.使用内容分发网络(CDN)</h2><h2 id="3-使用expires"><a href="#3-使用expires" class="headerlink" title="3.使用expires"></a>3.使用expires</h2><p>expires前面已经有提到了，http1.1中引入了cache-control字段，主要原因是expires的过期时间是一个绝对时间。因此要求服务器和客户端的时间基本上要保持同步。</p>
<h2 id="4-压缩组件"><a href="#4-压缩组件" class="headerlink" title="4. 压缩组件"></a>4. 压缩组件</h2><p>前面提到过，在请求头中添加Accept-Encoding可以设置浏览器支持的web服务器返回内容压缩编码类型。服务器在响应头中添加Content-Encoding。gzip是最流行和最有效的压缩方法。常用的还有deflate。</p>
<p>那我们应该压缩哪些内容呢？html css js以及响应的xml和json文本都是可以压缩的。图片和pdf不应该压缩。</p>
<p><strong>代理缓存问题</strong></p>
<p>想像一个场景，当浏览器通过代理来发送请求的情况下。假设针对某个url的第一个请求是不支持压缩的，所以服务器的响应肯定也是未压缩的，因此代理的缓存也是未压缩的。但是当第二个请求来自于一个支持压缩的浏览器的访问，那么代理还是会以之前缓存的未压缩的进行响应。反之，当第一个请求来自于一个支持压缩的浏览器，但是第二个请求来自于不支持压缩的浏览器，情况也就更加严重了。</p>
<p>解决方案：在响应中添加vary：Accept-Encoding，服务器根据一个或多个请求头来改变缓存的响应。这样代理就可以根据Accpet-Encoding的值的不同，缓存多个响应版本。</p>
<h2 id="5-将样式表放在顶部"><a href="#5-将样式表放在顶部" class="headerlink" title="5. 将样式表放在顶部"></a>5. 将样式表放在顶部</h2><h3 id="白屏"><a href="#白屏" class="headerlink" title="白屏"></a>白屏</h3><p>这里不得不说一句的是，如果将css放在底部或者是在head中以@import的方式引入样式表，都有可能会导致白屏现象，然后所有内容同时涌上屏幕。</p>
<h3 id="无样式内容闪烁（FOUC）"><a href="#无样式内容闪烁（FOUC）" class="headerlink" title="无样式内容闪烁（FOUC）"></a>无样式内容闪烁（FOUC）</h3><p>出现无样式现象是图片或其他的内容已经显示了，但是当css样式加载完了以后又重新渲染显示。原因同样是是因为将css放在了底部。</p>
<p>白屏和FOUC的选择：如果将css放在底部，浏览器有两种选择，白屏或者FOUC。如果css仍在加载，构建和呈现树就是一种浪费—-白屏。逐步显示，css加载完了再更新—FOUC</p>
<p>所以将样式表放在底部可能会导致白屏和FOUC（Flash of unstyled content）</p>
<h2 id="6-将脚本放在底部"><a href="#6-将脚本放在底部" class="headerlink" title="6. 将脚本放在底部"></a>6. 将脚本放在底部</h2><p>在下载解释执行js文件的时候，是不能下载其他的图片资源以及css样式的。</p>
<p>在下载除js的资源外，其他资源都是可以并行下载的。为什么js不能并行下载呢？</p>
<p>第一，多个js之间可能有依赖关系。<br>第二，脚本可能使用document.write来修改页面内容。</p>
<p><strong>defer</strong></p>
<p>正常来说脚本都是下载了然后就会解释执行，但是加上defer之后，就告诉浏览器，可以不用对我立即执行。但是，在用defer声明的脚本中，是不能出现document.write的；并且，其他脚本也是不能引用该defer脚本内的变量的。</p>
<h2 id="7-避免使用css表达式"><a href="#7-避免使用css表达式" class="headerlink" title="7. 避免使用css表达式"></a>7. 避免使用css表达式</h2><p>因为css表达式会被频繁地进行计算，当页面呈现和改变，滚动，用户鼠标拖拽都会重新求值。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol>
<li><p>一次性表达式，即在css中调用js函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">p&#123;</div><div class="line">    background-color: expression(altBgcolor(this))</div><div class="line">&#125;</div><div class="line">js:</div><div class="line">function altBgcolor(elem)&#123;</div><div class="line">    elem.style.backgroundColor = ....</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>或者直接在js中绑定事件函数中修改css样式。</p>
</li>
</ol>
<h2 id="8-使用外部js和css"><a href="#8-使用外部js和css" class="headerlink" title="8. 使用外部js和css"></a>8. 使用外部js和css</h2><p>如果将所有js文件都放在html中，第一次加载，内联式的性能会优于外联式。但是外联式有一个优点是可以缓存js和css文件。</p>
<p>这里又不得不说一个重用的问题，应该把各个页面相同的css部分提取出来，这样请求的时候就可以从缓存中获取。同时还有一个大的优化方向，即第一条说的请求数量越少越好。</p>
<h2 id="9-减少DNS的查找"><a href="#9-减少DNS的查找" class="headerlink" title="9. 减少DNS的查找"></a>9. 减少DNS的查找</h2><p>浏览器默认会将DNS和对应的IP缓存起来。但是服务器可以在返回的DNS记录中包含一个TTL（time-to-live），来表明可以被缓存的时间。但有些时候浏览器会忽略TTL而设置自己的时间限制。</p>
<p>所以如果浏览器支持keep-alive的话，那么一个持久的TCP链接将会一直使用，直至出现一定的空闲时间为止。（如IE的keepAliveTimeout:默认为1分钟）</p>
<h2 id="10-精简的js"><a href="#10-精简的js" class="headerlink" title="10. 精简的js"></a>10. 精简的js</h2><p>注释、不必要的空白字符都会被移除。</p>
<p><strong>混淆：</strong>移除注释和空白，同时将函数和变量的名字转化为更短的字符串。但是混淆可能会引入错误；维护和调试也更加困难。</p>
<p>常用的压缩工具：JSMin</p>
<p>精简CSS:合并相同的类，移除不使用的类。</p>
<h2 id="11-避免重定向"><a href="#11-避免重定向" class="headerlink" title="11. 避免重定向"></a>11. 避免重定向</h2><p>301：永久性重定向。返回301的时候通常会返回一个Location：url字段，表示需要被重定向到的url。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;meta http-equiv=&quot;refresh&quot; content=0; url=&quot;...&quot;&gt;这样也可以重定向。</div><div class="line"></div><div class="line">ducument.location也可以重定向。</div><div class="line"></div><div class="line">解决措施：加上结尾的‘/’,缺少斜线的话可能会导致重定向。</div><div class="line"></div><div class="line">也可以通过将appache2中的DirectionSlash off</div></pre></td></tr></table></figure>
<h2 id="12-删除重复的脚本"><a href="#12-删除重复的脚本" class="headerlink" title="12. 删除重复的脚本"></a>12. 删除重复的脚本</h2><h2 id="13-配置或移除Etag"><a href="#13-配置或移除Etag" class="headerlink" title="13. 配置或移除Etag"></a>13. 配置或移除Etag</h2><p>ETag： entity tag实体标签</p>
<p>ETag是为了解决if-modefied-Since的时间只能精确到s，并且可能内容并未改变，只是一些不重要的信息改变了，也会导致重新下载。</p>
<p>ETag的缺点：如果是在一个集群系统中，当浏览器从一台服务器中获取了原始组件之后，如果再向另一天服务器请求相同的内容，ETag是不会匹配的。</p>
<h2 id="14-使用AJAX缓存"><a href="#14-使用AJAX缓存" class="headerlink" title="14. 使用AJAX缓存"></a>14. 使用AJAX缓存</h2><p>加入cache-control字段和expires字段，来让ajax请求也支持缓存。</p>
]]></content>
      
        
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[浏览器缓存]]></title>
      <url>https://wutongshu1993.github.io/2017/04/01/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/</url>
      <content type="html"><![CDATA[<h1 id="浏览器缓存分类"><a href="#浏览器缓存分类" class="headerlink" title="浏览器缓存分类"></a>浏览器缓存分类</h1><h2 id="什么是浏览器缓存"><a href="#什么是浏览器缓存" class="headerlink" title="什么是浏览器缓存"></a>什么是浏览器缓存</h2><p>浏览器缓存(Brower Caching)是浏览器在本地磁盘对用户最近请求过的文档进行存储，当访问者再次访问同一页面时，浏览器就可以直接从本地磁盘加载文档。</p>
<p>浏览器缓存的优点有：</p>
<ol>
<li>减少了冗余的数据传输，节省了网费</li>
<li>减少了服务器的负担，大大提升了网站的性能</li>
<li>加快了客户端加载网页的速度</li>
</ol>
<h2 id="强制缓存和协商缓存"><a href="#强制缓存和协商缓存" class="headerlink" title="强制缓存和协商缓存"></a>强制缓存和协商缓存</h2><p>浏览器缓存主要有两类：缓存协商和彻底缓存，也有称之为协商缓存和强缓存。</p>
<p>浏览器在第一次请求发生后，再次请求时：</p>
<ol>
<li>浏览器会先获取该资源缓存的header信息，根据其中的expires和cahe-control判断是否命中强缓存，若命中则直接从缓存中获取资源，包括缓存的header信息，本次请求不会与服务器进行通信；<strong>注意！！强制缓存是在客户端进行判断的，不会传到服务器端。包括expires 和 maxage=num这两种形式</strong></li>
<li>如果没有命中强缓存，浏览器会发送请求到服务器，该请求会携带第一次请求返回的有关缓存的header字段信息（Last-Modified/IF-Modified-Since、Etag/IF-None-Match）,由服务器根据请求中的相关header信息来对比结果是否命中协商缓存，若命中，则服务器返回新的响应header信息更新缓存中的对应header信息，但是并不返回资源内容，它会告知浏览器可以直接从缓存获取；否则返回最新的资源内容</li>
</ol>
<h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p>强缓存是利用http的返回头中的Expires或者Cache-Control两个字段来控制的，用来表示资源的缓存时间。</p>
<h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h4><p>该字段是http1.0时的规范，它的值为一个绝对时间的GMT格式的时间字符串，比如Expires:Mon,18 Oct 2066 23:59:59 GMT。这个时间代表着这个资源的失效时间，在此时间之前，即命中缓存。这种方式有一个明显的缺点，由于失效时间是一个绝对时间，所以当服务器与客户端时间偏差较大时，就会导致缓存混乱。</p>
<h4 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h4><p>Cache-Control是http1.1时出现的header信息，主要是利用该字段的max-age值来进行判断，它是一个相对时间，例如Cache-Control:max-age=3600，代表着资源的有效期是3600秒（<strong>注意是秒！！</strong>）。cache-control除了该字段外，还有下面几个比较常用的设置值：</p>
<ul>
<li>no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。</li>
<li>no-store：直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。</li>
<li>public：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。</li>
<li>private：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。</li>
</ul>
<h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>协商缓存就是由服务器来确定缓存资源是否可用，所以客户端与服务器端要通过某种标识来进行通信，从而让服务器判断请求资源是否可以缓存访问，这主要涉及到下面两组header字段，这两组搭档都是成对出现的，即第一次请求的响应头带上某个字段（Last-Modified或者Etag），则后续请求则会带上对应的请求字段（If-Modified-Since或者If-None-Match），若响应头没有Last-Modified或者Etag字段，则请求头也不会有对应的字段。</p>
<h4 id="Last-Modify-If-Modify-Since"><a href="#Last-Modify-If-Modify-Since" class="headerlink" title="Last-Modify/If-Modify-Since"></a>Last-Modify/If-Modify-Since</h4><p>浏览器第一次请求一个资源的时候，服务器返回的header中会加上Last-Modify，Last-modify是一个时间标识该资源的最后修改时间，例如Last-Modify: Thu,31 Dec 2037 23:59:59 GMT。</p>
<p>当浏览器再次请求该资源时，request的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-Modify。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存。</p>
<p>如果命中缓存，则返回304，并且不会返回资源内容，并且不会返回Last-Modify。</p>
<h4 id="ETag-If-None-Match"><a href="#ETag-If-None-Match" class="headerlink" title="ETag/If-None-Match"></a>ETag/If-None-Match</h4><p>与Last-Modify/If-Modify-Since不同的是，Etag/If-None-Match返回的是一个校验码。ETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化。服务器根据浏览器上送的If-None-Match值来判断是否命中缓存。</p>
<p>与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化。</p>
<h4 id="为什么要有Etag"><a href="#为什么要有Etag" class="headerlink" title="为什么要有Etag"></a>为什么要有Etag</h4><p>你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag呢？HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：</p>
<ul>
<li>一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；</li>
<li>某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；</li>
<li>某些服务器不能精确的得到文件的最后修改时间。</li>
</ul>
<p>Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。</p>
<h2 id="和缓存有关的头部以及不同头部之间的优先级关系"><a href="#和缓存有关的头部以及不同头部之间的优先级关系" class="headerlink" title="和缓存有关的头部以及不同头部之间的优先级关系"></a>和缓存有关的头部以及不同头部之间的优先级关系</h2><ol>
<li>通用首部字段<br><img src="\images\通用头部.jpg" alt="通用头部"></li>
<li>请求头部<br><img src="\images\请求头部.jpg" alt="请求头部"></li>
<li><p>响应头部<br><img src="\images\响应首部.jpg" alt="响应首部"><br><img src="\images\实体首部.jpg" alt="实体首部"></p>
</li>
<li><p>缓存判断的过程</p>
</li>
</ol>
<p><img src="\images\粗略过程.jpg" alt="粗略过程"><br><img src="\images\详细过程.jpg" alt="详细过程"></p>
<h2 id="无法被缓存的请求"><a href="#无法被缓存的请求" class="headerlink" title="无法被缓存的请求"></a>无法被缓存的请求</h2><p>当然并不是所有请求都能被缓存。</p>
<p>无法被浏览器缓存的请求：</p>
<ol>
<li>HTTP信息头中包含Cache-Control:no-cache，pragma:no-cache（HTTP1.0），或Cache-Control:max-age=0等告诉浏览器不用缓存的请求</li>
<li>需要根据Cookie，认证信息等决定输入内容的动态请求是不能被缓存的</li>
<li>经过HTTPS安全加密的请求（有人也经过测试发现，ie其实在头部加入Cache-Control：max-age信息，firefox在头部加入Cache-Control:Public之后，能够对HTTPS的资源进行缓存，参考《HTTPS的七个误解》）</li>
<li>POST请求无法被缓存</li>
<li>HTTP响应头中不包含Last-Modified/Etag，也不包含Cache-Control/Expires的请求无法被缓存</li>
</ol>
<h2 id="浏览器清除缓存的方法"><a href="#浏览器清除缓存的方法" class="headerlink" title="浏览器清除缓存的方法"></a>浏览器清除缓存的方法</h2><ol>
<li><p>meta元数据，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;META HTTP-EQUIV=&quot;pragma&quot; CONTENT=&quot;no-cache&quot;&gt; </div><div class="line">&lt;META HTTP-EQUIV=&quot;Cache-Control&quot; CONTENT=&quot;no-cache, must-revalidate&quot;&gt; </div><div class="line">&lt;META HTTP-EQUIV=&quot;expires&quot; CONTENT=&quot;0&quot;&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>用ajax请求最新文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">beforeSend :function(xmlHttp)&#123; </div><div class="line">        xmlHttp.setRequestHeader(&quot;If-Modified-Since&quot;,&quot;0&quot;); </div><div class="line">        xmlHttp.setRequestHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;);</div><div class="line">     &#125;,</div><div class="line">或者直接用cache：false</div></pre></td></tr></table></figure>
</li>
<li><p>在请求的URL后加上随机数或者时间戳</p>
</li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> 缓存 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[session和cookie的区别和联系]]></title>
      <url>https://wutongshu1993.github.io/2017/04/01/session%E5%92%8Ccookie%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB/</url>
      <content type="html"><![CDATA[<h1 id="session-和cookie的区别和联系"><a href="#session-和cookie的区别和联系" class="headerlink" title="session 和cookie的区别和联系"></a>session 和cookie的区别和联系</h1><p>由于http协议是无连接，无状态的，因此服务器是不会保存客户信息的，需要借助cookie和session来完成。</p>
<h2 id="session和cookie的区别"><a href="#session和cookie的区别" class="headerlink" title="session和cookie的区别"></a>session和cookie的区别</h2><ol>
<li>存储位置不一样，cookie存在浏览器，session存在服务器端。</li>
<li>存取类型不同，cookie只能存Unicode字符或者二进制数据，需要先进行编码。而session可以存取任何类型的数据。</li>
<li>有效时间不同，对于非持久性session来说，session只在会话期间有效。为防止内存溢出，服务器会把长时间内没有活跃的Session从内存删除。这个时间就是Session的超时时间。如果超过了超时时间没访问过服务器，Session就自动失效了。而cookie有会话cookie和永久cookie之分。</li>
<li>跨域支持不同，cookie对该域及其子域都是有效的，session只对当前域有效。</li>
<li>容量大小也不同，cookie的容量最多4KB，session应该是没有限制的。</li>
</ol>
<h2 id="cookie的产生"><a href="#cookie的产生" class="headerlink" title="cookie的产生"></a>cookie的产生</h2><p>首先需要明白的cookie需要在每次请求指定domain域的时候都会携带，所以只有4kB的容量。</p>
<p>cookie是一段很小的文本信息，客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。通过在response中添加响应头setCookie实现，如：Set-Cookie: JsessionID=D356DFFF33AA134DAB; Max-Age=3600; Version=1。<br><img src="\images\服务器回写cookie样例.png" alt="image"><br> 客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。</p>
<p>当cookie已经产生了，下一次再发送请求的时候，就会根据cookie中的sessionID来查出服务器端对应的session，同时一个session中可以有多个attribute。</p>
<h2 id="session的用法"><a href="#session的用法" class="headerlink" title="session的用法"></a>session的用法</h2><p>在java中Session对应的类为javax.servlet.http.HttpSession类。getAttribute(Stringkey)和setAttribute(String key，Objectvalue)。常用的方法还有session.getId</p>
<p>session的存储有效的问题，不是常说session是在会话期间有效吗？那我们关掉浏览器后再次打开淘宝session怎么还存在呢？</p>
<p>情况是这样的。一般情况下，session都是存储在内存里，当服务器进程被停止或者重启的时候，内存里的session也会被清空，如果设置了session的持久化特性，服务器就会把session保存到硬盘上，当服务器进程重新启动或这些信息将能够被再次使用，Weblogic Server支持的持久性方式包括文件、数据库、客户端cookie保存和复制。 </p>
<h2 id="session和cookie的联系"><a href="#session和cookie的联系" class="headerlink" title="session和cookie的联系"></a>session和cookie的联系</h2><p>当程序需要为某个客户端的请求创建一个session的时候，服务器首先检查这个客户端的请求里是否已包含了一个session标识 - 称为session id，如果已包含一个session id则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（如果检索不到，可能会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存</p>
<p>其中cookie中的JsessionID对应的value就是在服务器端的session.getId()的返回值。</p>
<h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><p>如果客户端将cookie删除，那么还能访问到之前对应的session吗？</p>
<p>存了一些用户信息在服务器的session中，一个sessionID就对应一条session记录。将sessionID存入客户端的session当中。那么，当cookie被删除以后，如何才能访问之前的session呢？</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/linguoguo/p/5106618.html" target="_blank" rel="external">http://www.cnblogs.com/linguoguo/p/5106618.html</a></p>
<p><a href="http://justsee.iteye.com/blog/1570652" target="_blank" rel="external">http://justsee.iteye.com/blog/1570652</a> 很好的一篇文章</p>
]]></content>
      
        
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[js基本类型和引用类型小结]]></title>
      <url>https://wutongshu1993.github.io/2017/03/19/js%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%B0%8F%E7%BB%93/</url>
      <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>基本类型</strong>指的是简单的数据段，String Number Undefined Null Boolean这五种，他们的值保存在栈中。<strong>引用类型</strong>指的是可能由多个值构成的对象，值保存在堆中。</p>
<p>为什么会有堆和栈之分呢？因为每个函数执行时都会建立自己的内存栈，调用结束就释放内存。堆内存中的对象不会随着调用的结束而销毁，只有当一个对象没有任何引用变量引用时，系统的垃圾回收机制才会回收它。</p>
<h2 id="变量的赋值"><a href="#变量的赋值" class="headerlink" title="变量的赋值"></a>变量的赋值</h2><p>对于基本类型来说，如果从一个变量A向另一个变量B赋基本类型的值，会将A的值复制一份，然后把复制后的值给B。事实上就是A,B在栈中指向不同的位置，完全不相关。</p>
<p>对于引用类型来说，操作对象实际上操作的是对象的引用，（当为对象添加属性的时候，操作的是实际的对象）。当将Obj赋值给newObj时，也会将存储在变量对象obj中的值复制一份到为新变量newObj分配的空间中，但是这个值的副本实际上是一个指针，指向存储在堆中的一个对象。因此改变newObj会影响到obj。</p>
<p><img src="/images/引用赋值.jpg" alt="image"></p>
<h3 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h3><p>浅拷贝：两个对象指向的是堆中的同一个对象，一方改变，另一个也会改变。</p>
<h4 id="数组的深拷贝的实现："><a href="#数组的深拷贝的实现：" class="headerlink" title="数组的深拷贝的实现："></a>数组的深拷贝的实现：</h4><p>如果数组中的元素是基本类型，那么slice和concat是没有问题的，但是如果数组中的元素是对象类型的话，其实这两个函数也只是一个浅复制。</p>
<blockquote>
<p>concat方法返回一个新数组，它包含array的浅复制。（摘自javascript语言精粹 第8章）</p>
</blockquote>
<ol>
<li>var newArray = array.slice(0);//这个其实是浅复制</li>
<li>var newArray = array.contact();//之前一直理解错了，其实concat也是浅拷贝。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var arr = [&#123;name:&apos;lily&apos;&#125;,&#123;name:&apos;jack&apos;&#125;];</div><div class="line">var b = arr.concat([5,6]);</div><div class="line">b</div><div class="line">[Object, Object, 5, 6]</div><div class="line">arr[0].name = &apos;bob&apos;;</div><div class="line">b[0].name//输出&quot;bob&quot;</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="对象的深拷贝"><a href="#对象的深拷贝" class="headerlink" title="对象的深拷贝"></a>对象的深拷贝</h4><ol>
<li>var newObj = Json.parse( Json.stringfy(obj) );</li>
<li>var newObj = Object.create(obj);//把obj当做是newObj的原型进行创建<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function clone(obj) &#123;</div><div class="line">    var newObj = &#123;&#125;;</div><div class="line">    for(var i in obj)&#123;</div><div class="line">        newObj[obj[i]] = typeof obj[i] === &apos;object&apos; ? clone(obj[i]) : obj[i];</div><div class="line">    &#125;</div><div class="line">    return newObj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h2><h3 id="基本类型传参"><a href="#基本类型传参" class="headerlink" title="基本类型传参"></a>基本类型传参</h3><p>基本类型的传参和基本类型的赋值相同，都是复制一个临时变量。</p>
<p><img src="/images/基本类型的参数传递.jpg" alt="image"></p>
<p>因此，在函数addTen中改变的值只是一个临时变量的值，并不会影响到num本身。</p>
<h3 id="引用类型传参"><a href="#引用类型传参" class="headerlink" title="引用类型传参"></a>引用类型传参</h3><p>引用类型的传参传递的也是值，而不是引用。</p>
<p><img src="/images/引用类型传参1.jpg" alt="image"></p>
<p>这里，虽然是按值传递的，其实还是指向的是堆内存中唯一一个变量。</p>
<p>下面这个例子可以证明引用类型的参数传递是按值传递的，而不是按地址传递的。</p>
<p><img src="/images/引用类型按值传参证明.jpg" alt="image"></p>
<p>这里，在全局变量中有一个person，如果是按引用传递的，那么在setName函数内部对obj的改变应该会反映到person上面，但是并不会。事实上内部新建的obj之后，这个变量引用就是一个局部变量，函数执行完了就销毁了，并不会影响到外部的person。</p>
]]></content>
      
        
        <tags>
            
            <tag> 引用类型 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[BFC及其应用]]></title>
      <url>https://wutongshu1993.github.io/2017/03/16/BFC%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<h1 id="BFC是什么"><a href="#BFC是什么" class="headerlink" title="BFC是什么"></a>BFC是什么</h1><p>Box 是 CSS 布局的对象和基本单位， 直观点来说，就是一个页面是由很多个 Box 组成的。元素的类型和 display 属性，决定了这个 Box 的类型。 不同类型的 Box， 会参与不同的 Formatting Context（一个决定如何渲染文档的容器），因此Box内的元素会以不同的方式渲染。让我们看看有哪些盒子：</p>
<ul>
<li>block-level box:display 属性为 block, list-item, table 的元素，会生成 block-level box。并且参与 block fomatting context；</li>
<li>inline-level box:display 属性为 inline, inline-block, inline-table 的元素，会生成 inline-level box。并且参与 inline formatting context；<blockquote>
<p>BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。</p>
<h2 id="BFC的布局规则"><a href="#BFC的布局规则" class="headerlink" title="BFC的布局规则"></a>BFC的布局规则</h2></blockquote>
</li>
</ul>
<ol>
<li>内部的Box会在垂直方向，一个接一个地放置。</li>
<li>Box垂直方向的距离由margin决定。<strong>属于同一个BFC的两个相邻Box的margin会发生重叠</strong>（这就是大名鼎鼎的margin折叠）</li>
<li>每个元素的margin box的左边， 与包含块border</li>
<li>box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</li>
<li><strong>BFC的区域不会与float box重叠。</strong>（这个可以用来自适应布局）</li>
<li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li>
<li><strong>计算BFC的高度时，浮动元素也参与计算</strong>（这个可以用来清除浮动）</li>
</ol>
<h2 id="哪些元素会生成BFC"><a href="#哪些元素会生成BFC" class="headerlink" title="哪些元素会生成BFC"></a>哪些元素会生成BFC</h2><ul>
<li>根元素</li>
<li>float属性不为none</li>
<li>position为absolute或fixed</li>
<li>display为inline-block, table-cell, table-caption, flex, inline-flex</li>
<li>overflow不为visible</li>
</ul>
<h2 id="BFC的作用"><a href="#BFC的作用" class="headerlink" title="BFC的作用"></a>BFC的作用</h2><h3 id="自适应两栏布局"><a href="#自适应两栏布局" class="headerlink" title="自适应两栏布局"></a>自适应两栏布局</h3><p>一般来说加了浮动之后块级元素之间会出现重叠的现象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">body&#123;</div><div class="line">           width: 900px;</div><div class="line">           margin: 0 auto;</div><div class="line">       &#125;</div><div class="line">       .aside &#123;</div><div class="line">           width: 200px;</div><div class="line">           height: 150px;</div><div class="line">           float: left;</div><div class="line">           background: #f66;</div><div class="line">       &#125;</div><div class="line">       .content &#123;</div><div class="line">           height: 200px;</div><div class="line">           background: #fcc;</div><div class="line">       &#125;</div></pre></td></tr></table></figure></p>
<p><img src="/images/bfc1_1.jpg" alt="image">  </p>
<p>运用第5条规则：BFC的区域不会与float box重叠。所以我们只要触发右边的.content的BFC属性，便可是实现自适应，而不重叠的布局。</p>
<p><img src="/images/bfc1_2.jpg" alt="image"></p>
<h3 id="清除内部浮动："><a href="#清除内部浮动：" class="headerlink" title="清除内部浮动："></a>清除内部浮动：</h3><p>我们常说，清除内部浮动有如下几种办法：</p>
<ol>
<li>给父元素加上overflow:hidden或者是overflow:auto</li>
<li>在父元素::after加上clear:both</li>
<li>给父元素加上浮动</li>
</ol>
<p>其实清除浮动的原理就是利用触发父元素的BFC属性了。</p>
<h3 id="清除margin折叠"><a href="#清除margin折叠" class="headerlink" title="清除margin折叠"></a>清除margin折叠</h3><p>相邻的两个div，他们会发生margin折叠，清除margin折叠有以下方法：其核心在于使两个相邻的块级元素处于不同的BFC块中。</p>
<ol>
<li>给其中一个块级元素的外部再套上一个div元素，并触发这个元素的BFC属性</li>
</ol>
<p>事实上，不仅相邻的box元素会发生折叠，父子元素之间也会存在这样的现象。解决的方法是给父级元素加上内边距或者边框。</p>
]]></content>
      
        
        <tags>
            
            <tag> bfc margin折叠 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[懒加载]]></title>
      <url>https://wutongshu1993.github.io/2017/03/13/%E6%87%92%E5%8A%A0%E8%BD%BD/</url>
      <content type="html"><![CDATA[<ol>
<li><p>在html中给img指定两个图片资源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;img src=&quot;default.jpg&quot; dataSrc=&quot;img.jpg&quot;&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>lazyload函数</p>
</li>
</ol>
<p>核心在于当满足了img.offset &lt; scrolllTop + window.innerHeight的时候，替换img的 src<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var imgs = document.getElementsByTagName(&apos;img&apos;);</div><div class="line">    function lazyload()&#123;</div><div class="line">        var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;</div><div class="line">        var viewportSize = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;</div><div class="line">        var len = imgs.length;</div><div class="line">        var i , n = 0;</div><div class="line">        for(i = n; i &lt; len; i++)&#123;</div><div class="line">            var offsetTop = imgs[i].offsetTop;</div><div class="line">            if(offsetTop &lt; scrollTop + viewportSize)&#123;//显示真正的图片</div><div class="line">                imgs[i].src = imgs[i].getAttribute(&apos;dataSrc&apos;);</div><div class="line">            &#125;</div><div class="line">            n = i + 1;//避免每次for循环都是从0开始</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>优化：将lazyload函数绑定在window的onscroll事件中<br>window.onscroll = throttle(lazyload, 500, 1000);</li>
<li>优化<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     *</div><div class="line">     * @param fun 要执行的函数</div><div class="line">     * @param delay 延时的时间</div><div class="line">     * @param time 在time内执行一次</div><div class="line">     */</div><div class="line">    function throttle(fun, delay, time) &#123;</div><div class="line">        var timeout, startTime = new Date();</div><div class="line">        return function()&#123;</div><div class="line">            var context = this,</div><div class="line">                    args = arguments,</div><div class="line">                    curTime = new Date();</div><div class="line">            clearTimeout(timeout);</div><div class="line">            //如果到达了触发时间</div><div class="line">            if(curTime - startTime &gt;= time)&#123;</div><div class="line">                fun.apply(context, args);</div><div class="line">                startTime = curTime;</div><div class="line">            &#125;</div><div class="line">            else &#123;//没到达触发时间，重新设置定时器</div><div class="line">                timeout = setTimeout(fun, delay);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    lazyload();//至少执行一次</div><div class="line">    window.onscroll = throttle(lazyload, 500, 1000);</div></pre></td></tr></table></figure></li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> 优化 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo搭建博客]]></title>
      <url>https://wutongshu1993.github.io/2017/03/13/hello-hexo/</url>
      <content type="html"><![CDATA[<p>欢迎来到我的个人博客</p>
]]></content>
      
        
        <tags>
            
            <tag> nodejs， hexo， nextT </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>https://wutongshu1993.github.io/2017/03/13/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
      
        
    </entry>
    
  
  
</search>
